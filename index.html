<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" charset="utf-8"><title>Waigo.js</title><!--[if IE]><link rel="shortcut icon" href="img/logo_32x32.ico" /><![endif]--><link rel="shortcut icon" href="/img/logo_114x114.png"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/logo_144x144.png"><link rel="stylesheet" media="screen" href="/style.css"></head><body><header id="top" role="banner" class="navbar navbar-static-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target=".topmenu-navbar-collapse" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Waigo</a></div><div role="navigation" class="collapse navbar-collapse topmenu-navbar-collapse"><ul class="nav navbar-nav"><li class="active"><a id="guideNavItem" href="/#guide">Guide</a></li><li><a href="/api">API</a></li></ul><ul class="nav navbar-nav navbar-right"><li><a href="https://github.com/waigo/waigo">Github</a></li></ul></div></div></header><main id="content"><section id="banner"><div class="container"><div class="waigo-intro-banner"><div class="rays">  </div><div class="text"><h1>W</h1><p>Next-gen MVC framework for Node.js</p><ul class="meta"><li>v0.4.4</li><li><a href="https://github.com/waigo/waigo">github</a></li><li><a href="https://twitter.com/hiddentao">twitter</a></li></ul></div></div></div></section><section id="guide"><div class="container"><div class="row"><div role="main" class="col-md-9 waigo-guide-content"><div><h1 id="what-is-waigo-">What is Waigo?</h1>
<p><a href="http://travis-ci.org/waigo/waigo"><img src="https://secure.travis-ci.org/waigo/waigo.png" alt="Build Status"></a> <a href="https://npmjs.org/package/waigo"><img src="https://badge.fury.io/js/waigo.png" alt="NPM module"></a> <a href="https://codeclimate.com/github/waigo/waigo"><img src="https://codeclimate.com/github/waigo/waigo.png" alt="Code quality"></a></p>
<p>Waigo is a flexible MVC framework for building scalable and maintainable web applications.</p>
<p>Based on <a href="http://koajs.com">koa</a>, it uses <a href="http://tobyho.com/2013/06/16/what-are-generators/">generators</a> for asynchronous programming, removing the need for callbacks. Almost every aspect of the core framework can be easily extended or overridden.</p>
<p>This documentation (along with API docs) is available at <a href="http://waigojs.com">waigojs.com</a>.</p>
<p><strong>Waigo is still in beta (pre-1.0) so expect things to break!</strong></p>
<h1 id="getting-started">Getting started</h1>
<h2 id="installation">Installation</h2>
<p>Waigo requires <strong>Node.js v0.11.10 or above</strong>. This along with the command-line <code>--harmony</code> flag will give us the ES6 features we need. An easy 
way to manage multiples versions of Node.js is to use <a href="https://github.com/creationix/nvm">NVM</a>.</p>
<p>Once Node is installed go ahead and install Waigo:</p>
<pre><code class="lang-bash">$ npm install waigo
</code></pre>
<h2 id="hello-world">Hello world</h2>
<p>We will use the <a href="https://github.com/petkaantonov/bluebird">bluebird</a> library to iterate through our generators:</p>
<pre><code class="lang-bash">$ npm install bluebird
</code></pre>
<p>Create a new Javascript file (e.g. <code>app.js</code>) in your project folder with the following contents:</p>
<pre><code class="lang-javascript">var Promise = require(&#39;bluebird&#39;),
  waigo = require(&#39;waigo&#39;);

// Generator co-routine
Promise.spawn(function*() {
  // Initialise waigo module loading system
  yield* waigo.init();
  // Start the server
  yield* waigo.load(&#39;server&#39;).start();
})
  .then(function(err) {
    console.log(err);  
  });
</code></pre>
<p>Let&#39;s disable database connections and sesssions for now:</p>
<pre><code class="lang-bash">$ mkdir -p src/config
$ echo &quot;exports.session = null; exports.db = null;&quot; &gt; src/config/development.js
</code></pre>
<p>Finally, we need a template:</p>
<pre><code class="lang-bash">$ mkdir -p src/views
$ echo &quot;p= title&quot; &gt; src/views/index.jade
</code></pre>
<p>Start the app:</p>
<pre><code class="lang-bash">$ node --harmony app.js
</code></pre>
<p>Visit <a href="http://localhost:3000"><a href="http://localhost:3000">http://localhost:3000</a></a> and you should see the following HTML output: </p>
<pre><code class="lang-html">&lt;p&gt;Hello world!&lt;/p&gt;
</code></pre>
<p>Waigo is designed to make it easy to re-use your URL routes as JSON APIs. Visit <a href="http://localhost:3000/?format=json"><a href="http://localhost:3000/?format=json">http://localhost:3000/?format=json</a></a> and you should see:</p>
<pre><code class="lang-json">{
  title: &quot;Hello world!&quot;
}
</code></pre>
<p>This is all the data get which gets passed by the default controller to the <code>index.jade</code> template we created above. By default Waigo supports 
HTML and JSON output, and more <a href="#views">output formats</a> can be easily added.</p>
<h1 id="extend-and-override">Extend and Override</h1>
<p>In the &quot;Hello World&quot; example above you will have noticed:</p>
<pre><code class="lang-javascript">waigo.load(&#39;server&#39;)
</code></pre>
<p>When you want to use something provided by the framework you first have to load its module file through <code>waigo.load()</code>. This allows you to:</p>
<ol>
<li>Only load the parts of the framework you will actually use <em>(performance)</em>.</li>
<li><strong>Override any framework module file with your own version</strong> <em>(extendability and customization)</em>.</li>
</ol>
<p>When you want to load the <code>server</code> module file (as above) the loader will look for it in the following locations:</p>
<ol>
<li><code>&lt;your app folder&gt;/src/server.js</code></li>
<li><code>&lt;waigo npm module folder&gt;/src/server.js</code></li>
</ol>
<p><em>Note: if you have <a href="#plugins">plugins</a> installed their paths will also be searched.</em></p>
<p>So if you provide a <code>server.js</code> within your app&#39;s folder tree then Waigo will use that instead of the default one provided by the framework. This rules applies to <strong>every</strong> module file within the framework. </p>
<p>Thus if you don&#39;t like something provided by Waigo you can easily override it. But what if you specifically wanted the version of <code>server.js</code> provided by the framework? Just prefix <code>waigo:</code> to the module file name:</p>
<pre><code class="lang-javascript">// this will load the version of server.js provided by Waigo, and not the one provided by your app
waigo.load(&#39;waigo:server&#39;);
</code></pre>
<p>This also means you don&#39;t have to completely override the framework version. You can also <em>extend</em> it:</p>
<pre><code class="lang-javascript">// in file: &lt;your app folder&gt;/src/server.js

var waigo = require(&#39;waigo&#39;);

// load in Waigo framework version of server.js
module.exports = waigo.load(&#39;waigo:server&#39;);    

// override start()
exports.start = function*() {...}
</code></pre>
<p>Going back to the small &quot;Hello world&quot; example we built above, there is another call we make:</p>
<pre><code class="lang-javascript">yield* waigo.init();
</code></pre>
<p>Waigo works out which module files are available in the call to <code>waigo.init()</code>. It does this so that:</p>
<ol>
<li>Subsequent calls to <code>waigo.load()</code> are fast <em>(node&#39;s <code>require()</code> already caches loaded modules but having this extra optimisation doesn&#39;t hurt)</em>.</li>
<li>It can catch any <a href="#plugins">plugin conflicts</a> at startup <em>(rather than later on, when your app is already running)</em>.</li>
</ol>
<p><em>Note: The <code>.init()</code> method scanning for <code>.js</code> files in the folder trees of the framework, plugins as well as your app. It is thus recommended that your app&#39;s folder tree only contain code that will run in node. Place your front-end scrips in a different folder.</em></p>
<h2 id="plugins">Plugins</h2>
<p>You may wish to re-use functionality between different Waigo-based apps. In which case you can place such code into an NPM module - this is essentially what a <em>plugin</em> is. </p>
<p>To load a plugin at startup simply <code>npm install</code> it and then add it to one of either <code>dependencies</code>, <code>devDependencies</code> or <code>peerDependencies</code> within your <code>package.json</code> file. When <code>waigo.init()</code> is called Waigo will automatically scan <code>package.json</code> to get all plugins (by default it considers anything prefixed with <code>waigo-</code> as a plugin). It will then scan each plugin&#39;s <code>src</code> folder 
tree for available module files and register them internally.</p>
<p>Let&#39;s say you have a plugin - <code>waigo-mongo</code> - which enables the use of MongoDB database connections. And let&#39;s say it provides the following module file: <code>support/db/mongo.js</code>.</p>
<p>One <code>waigo.init()</code> has been called, if you then call <code>waigo.load(&#39;support/db/mongo&#39;)</code> the system will load the module file from the plugin module&#39;s <code>src</code> folder. If you were to now create <code>support/db/mongo.js</code> within your app&#39;s source folder tree then the app version would take precendence over the plugin version. </p>
<p>Strictly speaking, location precendence is as follows: <strong>App &gt; Plugins &gt; Waigo framework</strong>.</p>
<p>What would happen if you had two plugins which both provided the same module file? in this case the call to <code>waigo.init()</code> would fail with 
an error which looks like the following:</p>
<pre><code class="lang-bash">Error: Module &quot;support/db/mongo&quot; has more than one plugin implementation to choose from: waigo-plugin1, waigo-plugin2, ...
</code></pre>
<p>If you don&#39;t want to remove one of the offending plugins then pick which plugin&#39;s implementation you want to use by providing a version of the module file within your app&#39;s source folder tree. For example, if you wanted Waigo to use the implementation provided by <code>waigo-plugin1</code> then you would do:</p>
<pre><code class="lang-javascript">// in file: &lt;your app folder&gt;/src/support/db/mongo.js

var waigo = require(&#39;waigo&#39;);

// use the implementation from waigo-plugin1
module.exports = waigo.load(&#39;waigo-plugin1:support/db/mongo&#39;);
</code></pre>
<p><em>Note: See the <code>waigo-plugin1</code> prefix used in the call to <code>waigo.load()</code>? that basically tells the loader which module to load from.</em></p>
<p>To create and publish your own plugin to the wider community please follow these guidelines:</p>
<ul>
<li>Ensure your plugin name is prefixed with <code>waigo-</code> so that it&#39;s easy to find.</li>
<li>Write a good README.md for your plugin explaining what it&#39;s for and how to use it.</li>
<li>Add tests for your plugin and hook them upto <a href="https://travis-ci.org/">Travis CI</a>.</li>
<li>In your <code>package.json</code> tag your plugin with the <code>waigoplugin</code> keyword.</li>
</ul>
<p>To see a list of all available plugins visit <a href="https://www.npmjs.org/browse/keyword/waigoplugin"><a href="https://www.npmjs.org/browse/keyword/waigoplugin">https://www.npmjs.org/browse/keyword/waigoplugin</a></a>.</p>
<h1 id="configuration">Configuration</h1>
<p>Configuration info is loaded into the Koa app object and is always accessible at <code>app.config</code>.</p>
<p>The <code>src/config</code> folder holds configuration files loaded by Waigo during app startup. The <code>base</code> module file gets loaded first. Additional configuration modules then get loaded in the following order:</p>
<ol>
<li><code>config/&lt;node environment&gt;</code></li>
<li><code>config/&lt;node environment&gt;.&lt;current user&gt;</code></li>
</ol>
<p>Thus if node is running in <code>test</code> mode (i.e. <code>NODE_ENVIRONMENT=test</code>) and the user id of the process is <code>www-data</code> then the loader 
looks for the following module files and loads them if present, in the following order:</p>
<ol>
<li><code>config/test</code></li>
<li><code>config/test.www-data</code></li>
</ol>
<p>The base configuration object gets <em>extended</em> with each subsequently loaded config module file. This means that in each subsequent file you only need to override the configuration properties that differ.</p>
<p>The current mode is stored in <code>app.config.mode</code> and the user id in <code>app.config.user</code>.</p>
<h1 id="routing">Routing</h1>
<p>Routes are specified as a mapping in the <code>routes</code> module file in the following format:</p>
<pre><code class="lang-javascript">// in routes.js

module.exports = {
  &#39;GET /&#39; : &#39;main.index&#39;,
  &#39;PUT /newUser/:id&#39;: [&#39;sanitizeValue&#39;, &#39;checkRequestBodySize&#39;, &#39;main.newUser&#39;],
  ...
};
</code></pre>
<p>The key specifies the HTTP method (one of: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DEL</code>, <code>OPTIONS</code> and <code>HEAD</code>) and the route URL (relative to <code>app.config.baseURL</code>). Parameterized routing is supported thanks to <a href="https://github.com/koajs/trie-router">trie-router</a>.</p>
<p>The value for each key specifies the middleware chain that will handle that route. If the middleware name has a period (<code>.</code>) within it 
then it assumed to refer to a <code>controller.method</code>. Otherwise it is assumed to be the name of a <a href="#middleware">middleware</a> module file. </p>
<p>For the above example, Waigo will process the a <code>PUT</code> request made to <code>/newUser</code> in the following order:</p>
<ol>
<li>Load <code>support/middleware/sanitizeValue</code> and pass request to its exported method</li>
<li>Load <code>support/middleware/checkRequestBodySize</code> and pass request to its exported method</li>
<li>Load <code>controllers/main</code> and pass request to its <code>newUser</code> method</li>
</ol>
<p>If you wish to initialise a particular middleware with options then you can specify it as an <code>Object</code>. For example:</p>
<pre><code class="lang-javascript">// in routes.js

module.exports = {
  &#39;POST /signup&#39; : [ { id: &#39;bodyParser&#39;, limit: &#39;1kb&#39; }, &#39;main.signup&#39; ]
  ...
};
</code></pre>
<p>In the above configuration the <code>bodyParser</code> get initialized with the request body size limit of <code>1KB</code>.</p>
<h2 id="middleware">Middleware</h2>
<p>Waigo middleware works the same as Koa middleware. All middleware module files can be found under the <code>support/middleware</code> path. Additional middleware provided by your app and/or plugins should also sit under this path.</p>
<p>A middleware module file is expected to <code>export</code> a function which, when called, returns a generator function to add to the Koa middleware layer. For example:</p>
<pre><code class="lang-javascript">// in file: support/middleware/example.js

module.exports = function() {
  return function*(next) {
    // do nothing and pass through
    yield next;
  };
};
</code></pre>
<p>By default the following middleware is applied to all incoming requests:</p>
<ul>
<li><code>errorHandler</code> - catch and handle all errors thrown during request processing</li>
<li><code>outputFormats</code> - setup the response <a href="#views">output format</a></li>
<li><code>responseTime</code> - set the X-Response-Time header</li>
<li><code>sessions</code> - create and retrieve the active client session</li>
<li><code>staticResources</code> - handle requests made to static page resources, e.g. stylesheets, etc.</li>
</ul>
<h1 id="controllers">Controllers</h1>
<p>Controllers provide middleware as generator functions. The default controller (<code>controllers/main</code>) simply has:</p>
<pre><code class="lang-javascript">exports.index = function*(next) {
  yield this.render(&#39;index&#39;, {
    title: &#39;Hello world!&#39;
  });
};
</code></pre>
<p>A controller must either call <code>this.render()</code> or pass control to the <code>next</code> middleware in the request chain.</p>
<h1 id="models">Models</h1>
<p>At present Waigo does not provide a model layer in order to be as flexible as possible. Feel free to use an ORM, ODM, flat files or whatever type of model layer you want.</p>
<p>The default configuration (<code>app.config.db</code>) does however create a Mongo database connection using <a href="http://mongoosejs.com/">mongoose</a>. This connection (once established) is available through <code>app.db</code>. All supported database connection types are available in the <code>support/db</code> module file path.</p>
<h2 id="sessions">Sessions</h2>
<p>Sessions are available inside middleware using <code>this.session</code>:</p>
<pre><code class="lang-javascript">// inside a controller

exports.index = function*(next) {
  yield this.render(&#39;index&#39;, {
    name: this.session.userName
  });
};
</code></pre>
<p>Sessions are created and loaded by the <code>support/middleware/sessions</code> middleware, which internally uses <a href="https://github.com/hiddentao/koa-session-store">koa-session-store</a>.</p>
<p>By default sessions are stored in a Mongo database (you can re-use the Mongoose database connection) and cookies are issued to clients to keep track of sessions. The session configuration (<code>app.config.session</code>) expects you to provide cookie signing keys for use by <a href="https://github.com/jed/keygrip">Keygrip</a>:</p>
<pre><code class="lang-javascript">exports.session = {
  // cookie signing keys - these are used for signing cookies (using Keygrip) and should be set for your app
  keys: [&#39;use&#39;, &#39;your&#39;, &#39;own&#39;],
  // session cookie name
  name: &#39;waigo&#39;,
  // session storage
  store: {
    // session store type
    type: &#39;mongo&#39;,
    // session store config
    config: {
      url: &#39;mongodb://127.0.0.1:27017/waigo&#39;,
      collection: &#39;sessions&#39;
    }
  },
  // more cookie options
  cookie: {
    // cookie expires in...
    validForDays: 7,
    // cookie valid for url path...
    path: &#39;/&#39;
  }
};
</code></pre>
<h1 id="views">Views</h1>
<p>Views work the same as in other frameworks, with Jade as the default template language. But the view layer also supports the idea of different output formats.</p>
<p>Having different output formats makes it easy to re-use your route handlers (i.e. controllers) for dfferent types of front-ends. For example, you may wish to build a single-page web app or a mobile app which interacts with your back-end in a similar fashion to your normal web interface. Being able to re-use your controllers to output JSON makes life a easier in such cases.</p>
<p>The relevant configuration section (<code>app.config.outputFormats</code>) looks like:</p>
<pre><code class="lang-javascript">exports.outputFormats = {
  // List of enabled formats along with options to pass to each formatter.
  formats: {
    html: {
      // Folder relative to application root folder, in which to look for view templates.
      folder: &#39;views&#39;,
      // Default view template filename extension when not explicitly provided.
      ext: &#39;jade&#39;
      // Map file extension to rendering engine
      engine: {
        &#39;jade&#39;: &#39;jade&#39;
      }
    },
    json: {}
  },
  // Use this URL query parameter to determine output format.
  paramName: &#39;format&#39;,
  // Default format, in case URL query parameter which determines output format isn&#39;t provided.
  default: &#39;html&#39;
};
</code></pre>
<p>As you can see, HTML and JSON output formats are supported by default, with the specific format chosen via a configurable URL query parameter. The actual implementations of each output format can be found in the <code>support/outputFormats</code> module file path. </p>
<p>To add your own custom output format:</p>
<ol>
<li>Create a module file named after your format in the <code>support/outputFormats</code> module file path. </li>
<li>Add your format&#39;s name into the <code>app.config.outputFormats</code> configuration object along with any necessary configuration info.</li>
</ol>
<p>The associated middleware which sets up the output format for a request is located in <code>support/middleware/outputFormats</code>. It adds a <code>render()</code> method to the middleware context object. You use this as as follows:</p>
<pre><code class="lang-javascript">// in file: controllers/mycontroller.js

exports.userProfile = function*(next) {
  yield this.render(&#39;profile&#39;, {
    id: this.params.userId
  });
};
</code></pre>
<p>If we were to call the URL mapped to this controller method and append the <code>format=json</code> query parameter then the output would be of JSON type. The default JSON output formatter simply outputs the attribute data passed to the template, i.e. the output for above (assuming <code>this.params.userId</code> is 123) would be:</p>
<pre><code class="lang-javascript">{ 
  id: 123 
}
</code></pre>
<h2 id="view-objects">View objects</h2>
<p>When sending model data back to the user we may want to first modify it, e.g. format dates, remove parts of the data that the client does not need to see in the given context, etc. Waigo introduces the concept of <em>view objects</em> to support such functionality.</p>
<p>A view object is simply a plain Javascript object of key-value pairs which can be rendered. The <code>render()</code> method provided by the <a href="#views">output formats</a> middleware checks the passed-in template attributes to see if view objects can be generated for them. An object can generate a view object representation of itself if it implements the <code>HasViewObject</code> mixin (see <code>support/mixins.js</code>). Applying this mixin to 
a class requires you to implement a <code>toViewObject()</code> generator function for that class. This function takes a single argument - the context for the current request, allowing you to tailor the view object representation according to each individual request.</p>
<p>For example, let&#39;s say we have a model instance which holds data wish to send to the client:</p>
<pre><code class="lang-javascript">var waigo = require(&#39;waigo&#39;),
  mixins = waigo.load(&#39;support/mixins&#39;);

var Model = function(name) {
  this.name = name;
  this.id = 234;
};
mixins.apply(Model, mixins.HasViewObject);

Model.prototype.toViewObject = function*(ctx) {
  customKey = ctx.req.header[&#39;x-custom-key&#39;];

  if (&#39;test&#39; === customKey) {
    return {
      name: this.name,
      id: this.id
    };
  } else {
    return {
      name: this.name
    }
  }
};
</code></pre>
<p>In our controller we can easily pass this to the output format renderer:</p>
<pre><code class="lang-javascript">// controllers/main.js

exports.index = function*() {
  this.render(&#39;index&#39;, {
    person: new Model(&#39;John&#39;),
    stats: {
      age: 31,
      score: 10
    }
  });
}
</code></pre>
<p>The output (if we requested the JSON output format) will look like:</p>
<pre><code class="lang-javascript">{
  person: {
    name: &#39;John&#39;
  },
  age: {
    age: 31,
    score: 10
  }
}
</code></pre>
<p>Notice how the renderer didn&#39;t output the <code>id</code> attribute of our model instance. Also notice how the <code>stats</code> key-value pair was output 
just as it is. If a given attribute does not implement the <code>HasViewObject</code> mixin then it gets output as it is, unchanged.</p>
<p>If we now make the request with the <code>x-custom-key: test</code> header set then we will instead get:</p>
<pre><code class="lang-javascript">{
  person: {
    name: &#39;John&#39;,
    id: 234
  },
  age: {
    age: 31,
    score: 10
  }
}
</code></pre>
<p>All built-in <a href="#errors">error</a> classes (including form <a href="#validation">validation</a> errors) can generate view object representations of themselves. In fact, when the error handler sends an error response to the client it uses the view object representation of the error.</p>
<h1 id="forms">Forms</h1>
<p>Forms are treated as first-class citizens in Waigo. Each form used unique id; its configuration and input fields are specified in a file under the <code>forms/</code> path, the file name being the id of the form. </p>
<p>For example, here is how you might specify a simple signup form:</p>
<pre><code class="lang-javascript">// in file: forms/signup.js

module.exports = {
  fields: [
    {
      name: &#39;email&#39;,
      type: &#39;text&#39;,
      label: &#39;Email address&#39;
    },
    {
      name: &#39;password&#39;,
      type: &#39;password&#39;,
      label: &#39;Password&#39;
    },
    {
      name: &#39;confirm_password&#39;,
      type: &#39;password&#39;,
      label: &#39;Confirm password&#39;
    }
  ]  
};
</code></pre>
<p>The field <code>type</code> refers to the name of a module file under the <code>support/forms/fields/</code> path. So for the above form specification Waigo will expect the following paths to exist:</p>
<ul>
<li><code>support/forms/fields/text</code></li>
<li><code>support/forms/fields/password</code></li>
</ul>
<p>All field type classes inherit from the base <code>Field</code> class (found in <code>support/forms/field</code>). </p>
<p>To create an instance of the above form you would do:</p>
<pre><code class="lang-javascript">var waigo = require(&#39;waigo&#39;),
  Form = waigo.load(&#39;support/forms/form&#39;).Form;

var form = Form.new(&#39;signup&#39;);
</code></pre>
<p>Waigo will automatically look under the <code>forms/</code> file path to see if a form specification for the given id exists. It so it will load in this specification and return a <code>Form</code> instance.</p>
<h2 id="form-fields">Form fields</h2>
<p>When a form gets constructed it constructs and holds references to <code>Field</code> instances (see <code>support/forms/field</code>) depending on its field specification. </p>
<p>A naive implementation would have each <code>Field</code> instance stores its current field value. The problem with this approach is that 
if we have, say, a 1000 clients all using the same form we would need a 1000 instances of each field in the form in order to store the data for each client separately. </p>
<p>A better approach would be to store the data which differs from client to client in its own <code>Object</code> so that we can re-use <code>Field</code> instances across multiple <code>Form</code> instances. Waigo does this by storing all field values within a <code>state</code> property on the <code>Form</code> instance. The state can be get/set at any time and can also be passed in as a second parameter to the <code>Form</code> constructor:</p>
<pre><code class="lang-javascript">// save the form state
var form = Form.new(&#39;signup&#39;);
yield form.setValues( /* user input values */ );
this.session.formState = form.state;

...

// restore the form (and field values) to previous state
var form = Form.new(&#39;signup&#39;);
form.state = this.session.formState;

// we could also set the state during construction
var form = Form.new(&#39;signup&#39;, this.session.formState);
</code></pre>
<p>Let&#39;s say we wish to create another &quot;signup&quot; form for another client. We would again call <code>Form.new()</code>:</p>
<pre><code class="lang-javascript">var form2 = Form.new(&#39;signup&#39;);
</code></pre>
<p><code>Form.new()</code> will internally check the <code>Form</code> instance cache to see if a <code>signup</code> form has already been created. If so it passes that to the <code>Form</code> constructor which then copies the references to its <code>Field</code> instances and any other common data:</p>
<pre><code class="lang-javascript">form2.fields === form.fields;   // true
form2.state === form.state;     // false
</code></pre>
<h2 id="sanitization">Sanitization</h2>
<p>When setting form field values Waigo first sanitizes them. Sanitization is specified on a per-field basis in the form configuration. Let&#39;s trim all user input to our signup form: </p>
<pre><code class="lang-javascript">// in file: forms/signup.js

module.exports = {
  fields: [
    {
      name: &#39;email&#39;,
      type: &#39;text&#39;,
      label: &#39;Email address&#39;,
      sanitizers: [ &#39;trim&#39; ]
    },
    {
      name: &#39;password&#39;,
      type: &#39;password&#39;,
      label: &#39;Password&#39;,
      sanitizers: [ &#39;trim&#39; ]
    },
    {
      name: &#39;confirm_password&#39;,
      type: &#39;password&#39;,
      label: &#39;Confirm password&#39;,
      sanitizers: [ &#39;trim&#39; ]
    }
  ]  
};
</code></pre>
<p>Each item in the <code>sanitizers</code> array refers to the name of a module file under the <code>support/forms/sanitizers/</code> path. So for the above form specification Waigo will expect the following path to exist:</p>
<ul>
<li><code>support/forms/sanitizers/trim</code></li>
</ul>
<p>A sanitizer module exports a single function which should return a generator function (this performs the actual sanitization). For example, Waigo&#39;s built-in <code>trim</code> sanitizer looks like this:</p>
<pre><code class="lang-javascript">var validatorSanitizer = require(&#39;validator&#39;);

module.exports = function() {
  return function*(form, field, value) {
    return validatorSanitizer.trim(value);
  }
};
</code></pre>
<p>The actual sanitization function gets passed a <code>Form</code> and <code>Field</code> reference corresponding to the actual form and field it is operating on. This makes it possible to build complex sanitizers which can query other fields and the form itself. If sanitization fails then a <code>FieldSanitizationError</code> error gets thrown for the field for which it failed.</p>
<p>Note that you can set field values without sanitization processing:</p>
<pre><code class="lang-javascript">// without sanitization
form.fields.email.value = &#39;me@univers.com&#39;;

// with sanitization (this will set .value after sanitization is complete)
yield form.fields.email.setSanitizedValue(&#39;ram@hiddentao.com&#39;);
</code></pre>
<p>Setting values for multiple fields:</p>
<pre><code class="lang-javascript">// this calls Field.prototype.setSanitizedValue
yield form.setValues({
  email: &#39;ram@hiddentao.com&#39;,
  password: &#39;test&#39;
});
</code></pre>
<h2 id="validation">Validation</h2>
<p>Once form field values have been set we can validate them by calling <code>Form.prototype.validate()</code>. Validation is specified on a per-field basis in the form configuration. Let&#39;s validate our signup form:</p>
<pre><code class="lang-javascript">// in file: forms/signup.js

module.exports = {
  fields: [
    {
      name: &#39;email&#39;,
      type: &#39;text&#39;,
      label: &#39;Email address&#39;,
      sanitizers: [ &#39;trim&#39; ],
      validators: [ &#39;notEmpty&#39;, &#39;isEmailAddress&#39; ]
    },
    {
      name: &#39;password&#39;,
      type: &#39;password&#39;,
      label: &#39;Password&#39;,
      sanitizers: [ &#39;trim&#39; ],
      validators: [ &#39;notEmpty&#39;, { id: &#39;isLength&#39;, min: 8 } ]
    },
    {
      name: &#39;confirm_password&#39;,
      type: &#39;password&#39;,
      label: &#39;Confirm password&#39;,
      sanitizers: [ &#39;trim&#39; ],
      validators: [ { id: &#39;matchesField&#39;, field: &#39;password&#39; } ]
    }
  ]  
};
</code></pre>
<p>Each item in the <code>validators</code> array refers to the name of a module file under the <code>support/forms/validators/</code> path. When a validator (or even sanitizer) is specified as an <code>Object</code> then its <code>id</code> attribute is assumed to be its module file name. The <code>Object</code> itself is assumed to be a set of options to pass to the module during initialisation.</p>
<p>So for the above form specification Waigo will expect the following paths to exist:</p>
<ul>
<li><code>support/forms/validators/notEmpty</code></li>
<li><code>support/forms/validators/isLength</code></li>
<li><code>support/forms/validators/matchesField</code></li>
</ul>
<p>A validator module exports a single function which should return a generator function (this performs the actual validation). For example, Waigo&#39;s built-in <code>isEmailAddress</code> validator looks like this:</p>
<pre><code class="lang-javascript">var validator = require(&#39;validator&#39;);

module.exports = function() {
  return function*(form, field, value) {
    if (!validator.isEmail(value)) {
      throw new Error(&#39;Must be an email address&#39;);
    }
  }
};
</code></pre>
<p>The actual validation function gets passed a <code>Form</code> and <code>Field</code> reference corresponding to the actual form and field it is operating on. This makes it possible to build complex validators which can query other fields and the form itself.</p>
<p>When <code>Form.prototype.validate()</code> is called <code>Field.prototype.validate()</code> gets called for each field belonging to the form. For each field every validator gets run and all validation errors are grouped together within a single <code>FieldValidationError</code> instance. In <code>Form.prototype.validate()</code> all field validation errors are grouped together within a single <code>FormValidationError</code> instance. In this way validaton error reporting is very comprehensive and makes it easy to show the end-user exactly what failed to validate and why.</p>
<h1 id="logging">Logging</h1>
<p>Waigo provides support for <a href="https://github.com/flatiron/winston">winston</a> by default. The default Winston logging target (see <code>config/base</code>) is a Mongo database. For <code>development</code> mode it&#39;s set to the console. All uncaught exceptions and <code>error</code> events emitted on the koa app object get logged in this way.</p>
<p>You may use any logging library you wish. The <code>app.config.logging</code> configuration object both specifies the name of a logger (to be loaded from the <code>support/logging</code> path) and configuration to pass to that logger.</p>
<h1 id="errors">Errors</h1>
<p>The <code>support/middleware/errorHandler</code> middleware is responsible for handling all errors which get thrown during the request handling process. Errors get logged through the default logger as well as getting sent back to the client which made the original request. </p>
<p>It is highly recommended that your define and use your own error classes rather than use the built-in <code>Error</code> class. The <code>support/errors</code> module provides functionality to do this - your new error class will inherit from <code>RuntimeError</code> which in turn inherits from <code>Error</code>. <code>RuntimeError</code> allows you to set a HTTP status code along with the error message. This status code is used by the error handling middleware. For example:</p>
<pre><code class="lang-javascript">var waigo = require(&#39;waigo&#39;),
  errors = waigo.load(&#39;support/errors&#39;);

// FileSystemError will inherit from errors.RuntimeError
var FileSystemError = errors.define(&#39;FileSystemError&#39;);

// FileReadError will inherit from FileSystemError
var FileReadError = errors.define(&#39;FileReadError&#39;, FileSystemError);

...

throw new FileReadError(&#39;Error reading image file&#39;, 500);
// resulting error will be instance of: FileReadError, FileSystemError and Error and a HTTP status code of 500 will be returned to the client.
</code></pre>
<p><em>Note: Stack traces only get sent to the client if the <code>app.config.errorHandler.showStack</code> flag is turned on</em></p>
<h2 id="multiple-errors">Multiple errors</h2>
<p>Another built-in error class is <code>MultipleError</code>. Sometimes we may wish to report multiple errors related to a particular operation. 
A <code>MultipleError</code> allows us to group <code>Error</code> instances together. When it gets sent to the client in an error response its own view object 
representation and that of its &#39;child errors&#39; gets generated.</p>
<p>The <a href="#validation">form and field validation errors</a> both derive from <code>MultipleError</code>, allowing Waigo to collect and report multiple validation failures back to the client in an elegant and efficient manner.</p>
<h2 id="debugging">Debugging</h2>
<p>Sometimes in order to fix a problem it&#39;s useful to know what&#39;s going on inside the framework.</p>
<p>Waigo makes use of the <a href="https://github.com/visionmedia/debug">debug</a> utility internally in some parts. For instance, to debug the 
<a href="#extend-and-override">loading system</a> run your app with the <code>DEBUG</code> environment variable as follows:</p>
<pre><code class="lang-bash">$ DEBUG=waigo-loader node --harmony app.js
  waigo-loader Getting plugin names... +0ms
  waigo-loader Plugins to load:  +15ms
  waigo-loader Module &quot;routes&quot; will be loaded from source &quot;waigo&quot; +10ms
  waigo-loader Module &quot;server&quot; will be loaded from source &quot;waigo&quot; +0ms
  waigo-loader Module &quot;config/base&quot; will be loaded from source &quot;waigo&quot; +0ms
  ...
  waigo-loader Loading module &quot;server&quot; from source &quot;waigo&quot; +0ms
  ...
</code></pre>
<h1 id="contributing">Contributing</h1>
<p>Suggestions, bug reports and pull requests are welcome. Please see <a href="https://github.com/waigo/waigo/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a> for guidelines.</p>
<h1 id="license">License</h1>
<p>MIT - see <a href="https://github.com/waigo/waigo/blob/master/LICENSE.md">LICENSE.md</a></p>
</div></div><div class="col-md-3"><div role="complementary" class="waigo-content-menu hidden-print"><ul class="nav"><li><a href="#what-is-waigo-">What is Waigo?</a></li><li><a href="#getting-started">Getting started</a><ul class="nav"><li><a href="#installation">Installation</a></li><li><a href="#hello-world">Hello world</a></li></ul></li><li><a href="#extend-and-override">Extend and Override</a><ul class="nav"><li><a href="#plugins">Plugins</a></li></ul></li><li><a href="#configuration">Configuration</a></li><li><a href="#routing">Routing</a><ul class="nav"><li><a href="#middleware">Middleware</a></li></ul></li><li><a href="#controllers">Controllers</a></li><li><a href="#models">Models</a><ul class="nav"><li><a href="#sessions">Sessions</a></li></ul></li><li><a href="#views">Views</a><ul class="nav"><li><a href="#view-objects">View objects</a></li></ul></li><li><a href="#forms">Forms</a><ul class="nav"><li><a href="#form-fields">Form fields</a></li><li><a href="#sanitization">Sanitization</a></li><li><a href="#validation">Validation</a></li></ul></li><li><a href="#logging">Logging</a></li><li><a href="#errors">Errors</a><ul class="nav"><li><a href="#multiple-errors">Multiple errors</a></li><li><a href="#debugging">Debugging</a></li></ul></li><li><a href="#contributing">Contributing</a></li><li><a href="#license">License</a></li></ul><ul class="nav"><li class="back-to-top"><a href="#banner">Back to top</a></li></ul></div></div></div></div></section></main><footer role="contentinfo"><p>This page was <a href="https://github.com/waigo/waigojs.com-generator">generated</a> on Fri, 07 Mar 2014 13:02:57 GMT</p>
</footer><script type="text/javascript" src="/scripts.js"></script><script type="text/javascript">var _paq = _paq || [];
_paq.push(["setDomains", ["*.waigojs.com","*.waigo.github.io"]]);
_paq.push(["trackPageView"]);
_paq.push(["enableLinkTracking"]);
(function() {
  var u=(("https:" == document.location.protocol) ? "https" : "http") + "://piwik.hiddentao.com/";
  _paq.push(["setTrackerUrl", u+"piwik.php"]);
  _paq.push(["setSiteId", "3"]);
  var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0]; g.type="text/javascript";
  g.defer=true; g.async=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);
})();
</script></body></html>